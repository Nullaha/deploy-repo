import{a as j,d as G,q as k}from"./index-BFBhJYcK.js";import{p as m,l as E,a as b,u as $,f as u,L as q,s as y,i as I}from"./index-CVDLrp1o.js";import{i as g}from"./originUtils-D69mHv66.js";import{$ as z,w as x,I as N,v as O,j as B,y as C,P as V,l as F,d as H,c as T}from"./utils-D2OlFLuB.js";import{t as Q}from"./fetchService-D63-1g1h.js";import{a as W}from"./lazyLayerLoader-BAoDEOvN.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./saveAPIKeyUtils-DgrQkE58.js";import"./saveUtils-8XpmtF_5.js";const h="Feature Service",w="feature-layer-utils",X=`${w}-save`,Z=`${w}-save-as`,p=`${w}-saveall`,f=`${w}-saveall-as`;function v(e){return{isValid:q(e)&&(e.type!=="feature"||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function J(e){const a=[],r=[];for(const{layer:t,layerJSON:s}of e)t.isTable?r.push(s):a.push(s);return{layers:a,tables:r}}function M(e){return J([e])}async function R(e,a){return/\/\d+\/?$/.test(e.url)?M(a[0]):D(a,e)}async function D(e,a){if(e.reverse(),!a)return J(e);const r=await ee(a,e);for(const t of e)U(t.layer,t.layerJSON,r);return te(r,e),r}async function ee(e,a){let r=await e.fetchData("json");if(ae(r))return r;r||(r={}),re(r);const{layer:{url:t,customParameters:s,apiKey:o}}=a[0];return await ne(r,{url:t??"",customParameters:s,apiKey:o},a.map(n=>n.layer.layerId)),r}function ae(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function re(e){e.layers||(e.layers=[]),e.tables||(e.tables=[])}function te(e,a){const r=[],t=[];for(const{layer:s}of a){const{isTable:o,layerId:n}=s;o?t.push(n):r.push(n)}A(e.layers,r),A(e.tables,t)}function A(e,a){if(e.length<2)return;const r=[];for(const{id:t}of e)r.push(t);j(r.sort(L),a.slice().sort(L))&&e.sort((t,s)=>{const o=a.indexOf(t.id),n=a.indexOf(s.id);return o<n?-1:o>n?1:0})}function L(e,a){return e<a?-1:e>a?1:0}async function ne(e,a,r){const{url:t,customParameters:s,apiKey:o}=a,{serviceJSON:n,layersJSON:l}=await Q(t,{customParameters:s,apiKey:o}),i=P(e.layers,n.layers,r),c=P(e.tables,n.tables,r);e.layers=i.itemResources,e.tables=c.itemResources;const d=[...i.added,...c.added],_=l?[...l.layers,...l.tables]:[];await oe(e,d,t,_)}function P(e,a,r){const t=G(e,a,(o,n)=>o.id===n.id);e=e.filter(o=>!t.removed.some(n=>n.id===o.id));const s=t.added;return s.forEach(({id:o})=>{e.push({id:o})}),{itemResources:e,added:s.filter(({id:o})=>!r.includes(o))}}async function oe(e,a,r,t){const s=await se(a),o=a.map(({id:n,type:l})=>new(s.get(l))({url:r,layerId:n,sourceJSON:t.find(({id:i})=>i===n)}));await Promise.allSettled(o.map(n=>n.load())),o.forEach(n=>{const{layerId:l,loaded:i,defaultPopupTemplate:c}=n;if(!i||c==null)return;const d={id:l,popupInfo:c.toJSON()};n.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=n.operationalLayerType),U(n,d,e)})}async function se(e){const a=[];e.forEach(({type:s})=>{const o=le(s),n=W[o];a.push(n())});const r=await Promise.all(a),t=new Map;return e.forEach(({type:s},o)=>{t.set(s,r[o])}),t}function le(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer";break;case"Catalog Layer":a="CatalogLayer"}return a}function U(e,a,r){e.isTable?S(r.tables,a):S(r.layers,a)}function S(e,a){const r=e.findIndex(({id:t})=>t===a.id);r===-1?e.push(a):e[r]=a}function K(e,a){if(!e.length)throw new y(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ie(e,a){const r=e.map(t=>t.portalItem.id);if(new Set(r).size>1)throw new y(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function Y(e,a){const r=e.map(t=>t.layerId);if(new Set(r).size!==r.length)throw new y(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ce(e){K(e,p),await Promise.all(e.map(a=>a.load()));for(const a of e)F(a,p,v),H({layer:a,itemType:h,errorNamePrefix:p});ie(e,p),Y(e,p)}async function ue(e,a){const{url:r,layerId:t,title:s,fullExtent:o,isTable:n}=e,l=m(r);a.url=(l==null?void 0:l.serverType)==="FeatureServer"?r:`${r}/${t}`,a.title||(a.title=s),a.extent=null,n||o==null||(a.extent=await E(o)),b(a,u.METADATA),b(a,u.MULTI_LAYER),I(a,u.SINGLE_LAYER),n&&I(a,u.TABLE)}function ye(e,a){for(const o of e){const n=o.parsedUrl.path,l=m(n);if(!(l==null?void 0:l.url.path))throw new y(`${a}:invalid-parameters`,T(o,`has unsupported url pattern: ${n}`),{layer:o});const c=l==null?void 0:l.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new y(`${a}:invalid-parameters`,T(o,`has unsupported server type: ${c}`),{layer:o});if(c==="MapServer"&&e.length>1)throw new y(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const r=m(e[0].parsedUrl.path),t=r==null?void 0:r.url.path;if(!e.every(o=>{const n=m(o.parsedUrl.path);return(n==null?void 0:n.url.path)===t}))throw new y(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function pe(e){K(e,f),await Promise.all(e.map(a=>a.load()));for(const a of e)F(a,f,v);ye(e,f),Y(e,f)}async function fe(e,a){let r=0,t=0;for(const{isTable:n}of a)n?t++:r++;const s=a[0].parsedUrl.path,o=m(s);if(e.url=(o==null?void 0:o.serverType)==="FeatureServer"?o.url.path:s,e.title||(e.title=o.title),e.extent=null,r>0){const n=a.map(l=>l.fullExtent).filter(k).reduce((l,i)=>l.clone().union(i));n&&(e.extent=await E(n))}b(e,u.METADATA),$(e,u.MULTI_LAYER,a.length>1),$(e,u.SINGLE_LAYER,a.length===1),$(e,u.TABLE,t>0&&r===0),O(e)}async function Ae(e,a){return z({layer:e,itemType:h,validateLayer:v,createItemData:(r,t)=>R(t,[r]),errorNamePrefix:X},a)}async function Le(e,a){await ce(e);const r=e[0].portalItem,t=x(r),s=await Promise.all(e.map(n=>N(n,t,a))),o=await R(r,e.map((n,l)=>({layer:n,layerJSON:s[l]})));return O(r),await r.update({data:o}),await Promise.all(e.slice(1).map(n=>n.portalItem.reload())),g(t),r.clone()}async function Pe(e,a,r){return B({layer:e,itemType:h,validateLayer:v,createItemData:(t,s)=>Promise.resolve(M(t)),errorNamePrefix:Z,newItem:a,setItemProperties:ue},r)}async function Se(e,a,r){await pe(e);const t=C({itemType:h,errorNamePrefix:f,newItem:a}),s=x(t),o=await Promise.all(e.map(l=>N(l,s,r))),n=await D(e.map((l,i)=>({layer:l,layerJSON:o[i]})));await fe(t,e),await V(t,n,r);for(const l of e)l.portalItem=t.clone();return g(s),t}export{Ae as save,Le as saveAll,Se as saveAllAs,Pe as saveAs};
